import logging
from time import time, sleep

from datetime import datetime
import datetime as dt

import pandas as pd
from sfm_data_provider.interface.bshdata import BshData

from market_monitor.publishers.redis_publisher import RedisMessaging
from market_monitor.strategy.strategy_ui.StrategyUI import StrategyUI

from user_strategy.utils import CustomBDay
from market_monitor.strategy.common.trade_manager.book_memory import BookStorage
from market_monitor.strategy.common.trade_manager.flow_detector import FlowDetector
from market_monitor.strategy.common.trade_manager import TradeManager
from user_strategy.utils.bloomberg_subscription_utils.SubscriptionManager import SubscriptionManager


class CBTradeAnalysis(StrategyUI):

    def __init__(self, **kwargs) -> None:
        super().__init__(**kwargs)

        self.API = BshData(config_path=r"C:\AFMachineLearning\Libraries\MarketMonitor\etc\config\bshdata_config.yaml")
        self.all_isin = self.API.general.get_bond_isins(classe=(9,10))
        self.subscription_manager: None | SubscriptionManager = None
        self.book_storage: BookStorage = BookStorage()
        self.flow_detector = FlowDetector()
        self.yesterday = datetime.today() - CustomBDay
        self.instruments = self.all_isin
        # -------------------------------------- SETTING INSTRUMENTS ---------------------------------------------------
        self.mid = pd.Series(index=self.instruments, name="mid")
        self.trade_dashboard_messaging = RedisMessaging()
        self.trade_manager = TradeManager(self.book_storage,
                                          **kwargs["trade_manager"])

    def wait_for_book_initialization(self):

        while datetime.today().time() < dt.time(9, 1):
            return False

        while True:
            data = self.market_data.get_data_field(field=["BID", "ASK"])
            if data is not None and not data.empty:
                break
            sleep(1)

        self.on_start_strategy()
        return True

    def on_start_strategy(self):

        last_trades = self.trade_manager.get_trades()
        if not last_trades.empty:
            self.publish_trades_on_dashboard(last_trades)
            self.trade_dashboard_messaging.export_message(channel="trades_df",
                                                          value=last_trades,
                                                          date_format='iso',
                                                          orient="records")

    def on_market_data_setting(self) -> None:
        # Subscribe to original channel names with market: prefix
        subscription_manager = self.market_data.get_subscription_manager()
        for market in ["ETLX"]:
            for isin in self.instruments:
                # subscription_manager.subscribe_bloomberg(isin, f"{isin} corp", ["BID", "ASK"])
                subscription_manager.subscribe_kafka(id=isin,
                                                     symbol_filter=isin,
                                                     topic=f"COALESCENT_DUMA.{market}.BookBest",
                                                     fields_mapping={
                                                         "BID": "bidBestLevel.price",
                                                         "ASK": "askBestLevel.price",
                                                         "BID_SIZE": "bidBestLevel.quantity",
                                                         "ASK_SIZE": "askBestLevel.quantity"})



    def update_LF(self) -> None:
        try:
            self.publish_trades_on_dashboard(self.trade_manager.get_trades())
        except Exception as e:
            logging.error(e)

    def update_HF(self):
        if datetime.today().time() < dt.time(17, 29, 40):
            self.get_live_data()

    def on_trade(self, new_trades):
        new_trades['price_multiplier'] = 0.01

        processed_new = self.trade_manager.on_trade(new_trades)

        self.flow_detector.process_trades(processed_new)
        if self.flow_detector.has_new_flows():
            for flow in self.flow_detector.get_new_flows():  # â† Una volta sola!
                self.trade_dashboard_messaging.export_flow_detected(channel="trades_df", flow=flow)

        # Invia trades: nuovi parziali + parziali precedenti ora elaborati
        trades_to_publish = self.trade_manager.get_trades_to_publish(processed_new)
        self.publish_trades_on_dashboard(trades_to_publish)

        self.trade_dashboard_messaging.export_message(channel="trades_df_excel",
                                                      value=self.trade_manager.get_trades(n_of_trades=20),
                                                      date_format='iso',
                                                      orient="records")

    def publish_trades_on_dashboard(self, new_trades):

        start = time()
        self.trade_dashboard_messaging.export_message(channel="trades_df",
                                                      value=new_trades,
                                                      date_format='iso',
                                                      orient="records")

        logging.debug(f"processing trades takes {time() - start} seconds.")

    def on_book_initialized(self):
        pass

    def get_live_data(self):
        # Read from MarketStore using original channel names
        self.mid.update(self.market_data.get_data_field(field=["BID", "ASK"]).mean(axis=1))

        # Store book with timestamp
        self.book_storage.append(self.mid.copy())

    def on_stop(self):
        self.trade_manager.close()

    @property
    def instruments(self) -> list:
        return self._instruments

    @instruments.setter
    def instruments(self, value: list):
        self._instruments = value

    @instruments.getter
    def instruments(self) -> list[str]:
        return self._instruments

