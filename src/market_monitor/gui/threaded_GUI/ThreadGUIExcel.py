from __future__ import annotations

import logging
import os
import threading
import time
from datetime import datetime
from queue import Queue

import xlwings as xw

class ThreadGUIExcel(threading.Thread):
    """
    This class is used to consume a queue of updates generated by the strategy.
    """

    def __init__(self, queue: Queue, path: str | None = None, **kwargs):
        super().__init__(name="ThreadGUIExcel")
        self.path = path
        self.daemon = True
        self.name = "gui"
        self.Queue = queue
        self.wb: None | xw.Book = None
        self.sheet_list = []
        self.new_instance = kwargs.get("new_instance", False)
        self.sheets: None | xw.sheets = None
        self.my_trades = []
        self.kwargs = kwargs

    def open_excel_book(self, path):
        """
        Apre un file Excel e restituisce l'oggetto workbook. Se il file è già aperto, restituisce l'istanza esistente.

        Args:
            path (str): Percorso completo del file Excel da aprire.

        Returns:
            xw.Book: Oggetto workbook aperto.

        Raises:
            Exception: Se non è possibile aprire il file Excel dopo vari tentativi.
        """
        max_count, count = 50, 0
        if self.new_instance:
            for ex in xw.apps:
                while count < max_count:
                    try:
                        wb = ex.books.open(path)
                        return wb
                    except Exception as e:
                        logging.error(f"Errore nell'aprire il file nella nuova istanza: {e}")
                        count += 1
                        time.sleep(1)  # Attende un secondo prima di riprovare
                logging.error(
                    f"Impossibile aprire il file '{path}' in una nuova istanza di Excel. Tentando con una istanza in esecuzione.")

        while count < max_count:
            try:
                for app in xw.apps:
                    for wb in app.books:
                        if os.path.basename(wb.name) == os.path.basename(path):
                            logging.info(f"Il file '{path}' è già aperto in un'istanza di Excel.")
                            return wb
                break  # Breaks out of the loop if the file isn't found already open
            except Exception as e:
                logging.error(f"Errore nell'esaminare i workbook aperti: {e}")
                time.sleep(5)  # Attende un secondo prima di riprovare
                count += 1

        # If the file isn't found in any open workbook, try opening it
        try:
            wb = xw.Book(path)
            wb.activate(steal_focus=True)
            return wb
        except Exception as e:
            raise Exception(f"Impossibile aprire il file Excel: {path}. Prova a chiuderlo e riaprirlo.") from e

    def run(self):

        self.wb = self.open_excel_book(self.path)
        self.sheets = self.wb.sheets


        import queue

        while True:

            try:
                update = self.Queue.get(timeout=2)  # Timeout
                logging.debug(f"got update from gui queue, Queue size: {self.Queue.qsize()}")
                try:
                    try:
                        self._export_data(**update)
                    except Exception:
                        logging.error("error in thread gui", exc_info=True)

                    self.Queue.task_done()
                except Exception as e:
                    logging.warning(f"exporting error: {e}")
            except queue.Empty:
                logging.debug("No updates received within timeout period.")

    def _export_data(self, data, cell: str | None = 'B2', sheet: int | str = "Output", force: bool = False,
                     max_retries: int = 5, index=True, *args, **kwargs) -> None:
        """ Esporta il DataFrame df su Excel.

        :argument:
          - df: DataFrame that should be exported
          - cell: cell where the DataFrame should be exported
          - sheet: sheet_name where the DataFrame should be exported
          - force: if True, retry the operation if it fails
          - max_retries: the maximum number of retries if force is True
        """
        retries = 0
        start_time = time.time()
        if sheet is None: sheet = "Output"
        while retries < (max_retries if force else 1):
            try:
                if sheet in self.wb.sheet_names:
                    target_sheet = self.sheets[sheet]
                else:
                    target_sheet = self.wb.sheets.add(sheet)
                target_sheet.range(cell).options(header=True, index=index).value = data
            except AttributeError as e:
                logging.warning(f"Error in async export_data")
            except Exception as e:
                logging.debug(f"Unexpected error in async export_data")
            retries += 1
            if force: logging.debug(f"Retrying... ({retries}/{max_retries})")
        logging.debug(f"exporting data to excel: {time.time() - start_time:.4f}")


    def stop(self):
        self.show_message_box("the strategy is stopping!", "WARNING")
        pass

    @staticmethod
    def show_message_box(message: str, title: str):
        """ Show a message box in Excel using xlwings. """
        xw.apps.active.alert(message, title)


if __name__ == "__main__":

    queue = Queue()
    GUI = ThreadGUIExcel(queue)
    response = input("continua?")
    print(response)
    GUI.start()
    try:
        while True:
            update = datetime.now()
            queue.put({"data": update})
            time.sleep(1)
    except KeyboardInterrupt:
        GUI.stop()
