import asyncio
import logging
import os
import threading
from queue import Queue

import pandas as pd
from watchdog.events import FileSystemEventHandler
from watchdog.observers import Observer
from market_monitor.utils.SQLUtils.sqliteTradesConnection import SqliteTradesConnection
from market_monitor.utils.enums import TradeType


class MyEventHandler(FileSystemEventHandler):

    def __init__(self, trade_thread: 'trade'):
        super().__init__()
        self.trade_thread = trade_thread

    def on_modified(self, event):
        """
        Callback triggered when the observed DB is modified
        Args:
            event: wathcdog event

        Returns: None

        """
        if not event.is_directory:
            try:
                if self.trade_thread.is_initialized():
                    market_trades, own_trades = self.trade_thread.conn.get_last_trade()
                else:
                    self.trade_thread.on_start_of_day()
                    return
            except Exception as e:
                logging.error(f"Error while getting market trades: {e}")
                return
            if not market_trades.empty:
                market_trades.set_index("ticker", inplace=True)
                self.trade_thread.put_in_queue(TradeType.MARKET, market_trades)
                logging.info(f"New market trades added to the queue: {market_trades.index.tolist()}")
            if not own_trades.empty:
                own_trades.set_index("ticker", inplace=True)
                self.trade_thread.put_in_queue(TradeType.OWN, own_trades)
                logging.info(f"New own trades added to the queue: {own_trades.index.tolist()}")


class TradeThread(threading.Thread):

    """
    Thread that react when a new trade is received. On event read from a DB generated by MarketTrades, and puts new
     element in a shared queue.
     """
    def __init__(self, locker: threading.Lock, queue: Queue | asyncio.Queue, db_name: str, path: str):
        super().__init__()
        self._stop: bool = False
        self.daemon = True
        self.locker = locker
        self.queue_trade: Queue | asyncio.Queue = queue

        self.asynchronous: bool = isinstance(queue, asyncio.Queue)  # Verifica se è asyncio.Queue
        self.path = path
        self.conn = SqliteTradesConnection(os.path.join(path,db_name))
        self.observer = Observer()
        self.observer.name = "Observer"
        self.name = "trade"

        # Crea l'event loop se siamo in modalità asincrona
        self.loop = asyncio.new_event_loop() if self.asynchronous else None
        self.event_handler = MyEventHandler(self)  # Passa l'istanza di trade
        self._is_initialized: bool = False
        self.on_start_of_day()

    def on_start_of_day(self):

        try:
            market_trades, own_trades = self.conn.get_all_trades()
            market_trades.set_index("ticker", inplace=True)
            self.put_in_queue(TradeType.MARKET, market_trades)

            try:
                own_trades.set_index("ticker", inplace=True)
                if not own_trades.empty:
                    self.put_in_queue(TradeType.OWN, own_trades)
            except KeyError as e:
                logging.warning(f"own_trades table is Empty. Please update market trades viewer to the latest one.")

            logging.info("All trades added to the queues at the start of the day.")
            self._is_initialized = True
        except Exception as e:
            logging.error(f"Error while getting market trades on start_of_day: {e}")


    def run(self):
        logging.info(f"Starting observer for path: {self.path}")
        self.observer.schedule(self.event_handler, self.path, recursive=False)
        self.observer.start()

        if self.asynchronous:
            # Avvia l'event loop asincrono nel thread
            asyncio.set_event_loop(self.loop)
            try:
                self.loop.run_forever()
            except Exception as _:
                logging.error(f"Error in async loop")
            finally:
                self.observer.stop()
                self.observer.join()
                logging.info("Observer stopped.")
                self.loop.stop()

        try:
            while not self._stop:
                self.observer.join(1)
        except KeyboardInterrupt:
            self.stop()

    def stop(self):
        self._stop = True
        self.observer.stop()
        self.observer.join()
        logging.info("Observer stopped.")
        if self.asynchronous:
            self.loop.stop()

    def put_in_queue(self, trade_type: TradeType, item: pd.DataFrame):
        """Aggiunge l'elemento alla coda in modo sicuro. Se è una coda asyncio, utilizza await per l'inserimento."""
        if self.asynchronous:
            # Se la coda è asyncio.Queue, esegui l'inserimento nel loop asincrono
            asyncio.run_coroutine_threadsafe(self.queue_trade.put((trade_type, item)), self.loop)
        else:
            # Se è una queue.Queue, usa put in modo sincrono
            self.queue_trade.put((trade_type, item))

    def is_initialized(self):
        return self._is_initialized
