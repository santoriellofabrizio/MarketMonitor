import asyncio
import logging
import os
import sqlite3
import threading
import time
from enum import Enum
from pathlib import Path
from queue import Queue
from typing import Tuple

import pandas as pd
from watchdog.events import FileSystemEventHandler
from watchdog.observers import Observer

logger = logging.getLogger(__name__)


class TradeType(Enum):
    MARKET = 1
    OWN = 2

class MyEventHandler(FileSystemEventHandler):

    def __init__(self, trade_thread: 'trade'):
        super().__init__()
        self.trade_thread = trade_thread

    def on_modified(self, event):
        """
        Callback triggered when the observed DB is modified
        Args:
            event: wathcdog event

        Returns: None

        """
        if not event.is_directory:
            try:
                if self.trade_thread.is_initialized():
                    market_trades, own_trades = self.trade_thread.conn.get_last_trade()
                else:
                    self.trade_thread.on_start_of_day()
                    return
            except Exception as e:
                logging.error(f"Error while getting market trades: {e}")
                return
            if not market_trades.empty:
                market_trades.set_index("ticker", inplace=True)
                self.trade_thread.put_in_queue(TradeType.MARKET, market_trades)
                logging.info(f"New market trades added to the queue: {market_trades.index.tolist()}")
            if not own_trades.empty:
                own_trades.set_index("ticker", inplace=True)
                self.trade_thread.put_in_queue(TradeType.OWN, own_trades)
                logging.info(f"New own trades added to the queue: {own_trades.index.tolist()}")


class TradeThread(threading.Thread):

    """
    Thread that react when a new trade is received. On event read from a DB generated by MarketTrades, and puts new
     element in a shared queue.
     """
    def __init__(self, locker: threading.Lock, queue: Queue | asyncio.Queue, path: str):
        super().__init__()
        self.running: bool = False
        self.daemon = True
        self.locker = locker
        self.queue_trade: Queue | asyncio.Queue = queue

        self.asynchronous: bool = isinstance(queue, asyncio.Queue)  # Verifica se è asyncio.Queue
        self.path = path
        self.conn = SqliteTradesConnection(path)
        self.observer = Observer()
        self.observer.name = "ObserverTrades"
        self.name = "TradeThread"

        # Crea l'event loop se siamo in modalità asincrona
        self.loop = asyncio.new_event_loop() if self.asynchronous else None
        self.event_handler = MyEventHandler(self)  # Passa l'istanza di trade
        self._is_initialized: bool = False
        self.on_start_of_day()

    def on_start_of_day(self):

        try:
            market_trades, own_trades = self.conn.get_all_trades()
            market_trades.set_index("ticker", inplace=True)
            self.put_in_queue(TradeType.MARKET, market_trades)

            try:
                own_trades.set_index("ticker", inplace=True)
                if not own_trades.empty:
                    self.put_in_queue(TradeType.OWN, own_trades)
            except KeyError as e:
                logging.warning(f"own_trades table is Empty. Please update market trades viewer to the latest one.")

            logging.info("All trades added to the queues at the start of the day.")
            self._is_initialized = True
        except Exception as e:
            logging.error(f"Error while getting market trades on start_of_day: {e}")

    def run(self):
        logging.info(f"Starting observer for path: {self.path}")
        path = Path(self.path).parent if self.path.endswith(".db") else self.path

        self.observer.schedule(self.event_handler, str(path), recursive=False)
        self.observer.start()

        if self.asynchronous:
            asyncio.set_event_loop(self.loop)
            try:
                self.loop.run_forever()
            finally:
                self.stop()
        else:
            # Loop principale: resta vivo finché non viene chiamato stop()
            while not self.running:
                # Dormiamo un po' per non consumare CPU,
                # l'evento reale è gestito dall'EventHandler in un altro thread
                threading.Event().wait(1)

                # Quando usciamo dal loop, puliamo tutto
        self.observer.stop()
        self.observer.join()
        logging.info("TradeThread stopped.")

    def stop(self):
        self.running = True
        self.observer.stop()
        self.observer.join()
        logging.info("Observer stopped.")
        if self.asynchronous:
            self.loop.stop()

    def put_in_queue(self, trade_type: TradeType, item: pd.DataFrame):
        """Aggiunge l'elemento alla coda in modo sicuro. Se è una coda asyncio, utilizza await per l'inserimento."""
        if self.asynchronous:
            # Se la coda è asyncio.Queue, esegui l'inserimento nel loop asincrono
            asyncio.run_coroutine_threadsafe(self.queue_trade.put((trade_type, item)), self.loop)
        else:
            # Se è una queue.Queue, usa put in modo sincrono
            self.queue_trade.put((trade_type, item))

    def is_initialized(self):
        return self._is_initialized

# Gestione del warning: il filtro è ora globale per tutte le istanze di questa classe
class SqliteTradesConnection:

    def __init__(self, path: str):
        self.path = path
        self.n_market_trades, self.n_own_trades = 0, 0
        while (count := 0) < 5:
            try:
                self.conn: sqlite3.Connection = sqlite3.connect(self.path)
                break
            except:
                time.sleep(5)
                count += 1

        # Messaggio di warning
        self.warning_message = "No OWN_TRADES table found. Please update market trades viewer to the latest one."

        # Se il logger non ha già un handler, aggiungi uno per stampare i messaggi di warning nella console
        if not logger.hasHandlers():
            handler = logging.StreamHandler()
            formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
            handler.setFormatter(formatter)
            logger.addHandler(handler)

        # Filtro per evitare che lo stesso warning venga loggato più di una volta
        if not hasattr(self, '_warning_logged'):
            self._warning_logged = False

    def _log_warning_once(self):
        if not self._warning_logged:
            logger.warning(self.warning_message)
            self._warning_logged = True

    def get_last_trade(self) -> Tuple[pd.DataFrame, pd.DataFrame]:
        conn: sqlite3.Connection = sqlite3.connect(self.path)
        market_trades = pd.read_sql_query(f"""SELECT * FROM TRADES LIMIT -1 OFFSET {self.n_market_trades}""", conn)
        try:
            own_trades = pd.read_sql_query(f"""SELECT * from OWN_TRADES LIMIT -1 OFFSET {self.n_own_trades}""", conn)
        except Exception as e:  # Uso di Exception per catturare qualsiasi tipo di errore
            self._log_warning_once()  # Logga il warning solo la prima volta
            own_trades = pd.DataFrame()  # Assegna un DataFrame vuoto in caso di errore
        finally:
            conn.close()  # Assicurati che la connessione venga sempre chiusa
        return self._elaborate_trade(market_trades, own_trades)

    def get_all_trades(self) -> Tuple[pd.DataFrame, pd.DataFrame]:
        conn: sqlite3.Connection = sqlite3.connect(self.path)
        market_trades = pd.read_sql_query(f"""SELECT * FROM TRADES""", conn)
        try:
            own_trades = pd.read_sql_query(f"""SELECT * from OWN_TRADES""", conn)
        except Exception as e:  # Uso di Exception per catturare qualsiasi tipo di errore
            self._log_warning_once()  # Logga il warning solo la prima volta
            own_trades = pd.DataFrame()  # Assegna un DataFrame vuoto in caso di errore
        finally:
            conn.close()  # Assicurati che la connessione venga sempre chiusa
        return self._elaborate_trade(market_trades, own_trades)

    def _elaborate_trade(self, market_trades: pd.DataFrame,
                         own_trades: pd.DataFrame) -> Tuple[pd.DataFrame, pd.DataFrame]:
        self.n_market_trades += len(market_trades)
        self.n_own_trades += len(own_trades)

        # Gestisci "last_update" solo se own_trades non è vuoto
        market_trades["last_update"] = pd.to_datetime(market_trades["last_update"], dayfirst=True)
        if not own_trades.empty:  # Controlla che own_trades non sia vuoto
            own_trades["last_update"] = pd.to_datetime(own_trades["last_update"], dayfirst=True)
            own_trades = own_trades.rename(columns={"side": "own_trade"})

        return market_trades, own_trades
